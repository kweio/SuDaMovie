{"ast":null,"code":"'use strict';\n\nvar url = require('url');\nvar gitHosts = require('./git-host-info.js');\nvar GitHost = module.exports = require('./git-host.js');\nvar protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n};\nfunction protocolToRepresentation(protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);\n}\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n};\nvar cache = {};\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') return;\n  var key = giturl + JSON.stringify(opts || {});\n  if (!(key in cache)) {\n    cache[key] = fromUrl(giturl, opts);\n  }\n  return cache[key];\n};\nfunction fromUrl(giturl, opts) {\n  if (giturl == null || giturl === '') return;\n  var url = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? 'github:' + giturl : giturl);\n  var parsed = parseGitUrl(url);\n  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\\/)?([^#]+)/);\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName];\n      var auth = null;\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = parsed.auth;\n      }\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;\n      var user = null;\n      var project = null;\n      var defaultRepresentation = null;\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]);\n        project = decodeURIComponent(shortcutMatch[3].replace(/\\.git$/, ''));\n        defaultRepresentation = 'shortcut';\n      } else {\n        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return;\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return;\n        if (!parsed.path) return;\n        var pathmatch = gitHostInfo.pathmatch;\n        var matched = parsed.path.match(pathmatch);\n        if (!matched) return;\n        /* istanbul ignore else */\n        if (matched[1] !== null && matched[1] !== undefined) {\n          user = decodeURIComponent(matched[1].replace(/^:/, ''));\n        }\n        project = decodeURIComponent(matched[2]);\n        defaultRepresentation = protocolToRepresentation(parsed.protocol);\n      }\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);\n    } catch (ex) {\n      /* istanbul ignore else */\n      if (ex instanceof URIError) {} else throw ex;\n    }\n  }).filter(function (gitHostInfo) {\n    return gitHostInfo;\n  });\n  if (matches.length !== 1) return;\n  return matches[0];\n}\nfunction isGitHubShorthand(arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg);\n}\nfunction fixupUnqualifiedGist(giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl);\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host;\n  } else {\n    return giturl;\n  }\n}\nfunction parseGitUrl(giturl) {\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);\n  if (!matched) {\n    var legacy = url.parse(giturl);\n    // If we don't have url.URL, then sorry, this is just not fixable.\n    // This affects Node <= 6.12.\n    if (legacy.auth && typeof url.URL === 'function') {\n      // git urls can be in the form of scp-style/ssh-connect strings, like\n      // git+ssh://user@host.com:some/path, which the legacy url parser\n      // supports, but WhatWG url.URL class does not.  However, the legacy\n      // parser de-urlencodes the username and password, so something like\n      // https://user%3An%40me:p%40ss%3Aword@x.com/ becomes\n      // https://user:n@me:p@ss:word@x.com/ which is all kinds of wrong.\n      // Pull off just the auth and host, so we dont' get the confusing\n      // scp-style URL, then pass that to the WhatWG parser to get the\n      // auth properly escaped.\n      var authmatch = giturl.match(/[^@]+@[^:/]+/);\n      /* istanbul ignore else - this should be impossible */\n      if (authmatch) {\n        var whatwg = new url.URL(authmatch[0]);\n        legacy.auth = whatwg.username || '';\n        if (whatwg.password) legacy.auth += ':' + whatwg.password;\n      }\n    }\n    return legacy;\n  }\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] + '/' + matched[3] + (matched[4] || '')\n  };\n}","map":{"version":3,"names":["url","require","gitHosts","GitHost","module","exports","protocolToRepresentationMap","protocolToRepresentation","protocol","slice","authProtocols","cache","fromUrl","giturl","opts","key","JSON","stringify","fixupUnqualifiedGist","isGitHubShorthand","parsed","parseGitUrl","shortcutMatch","match","matches","Object","keys","map","gitHostName","gitHostInfo","auth","committish","hash","decodeURIComponent","substr","user","project","defaultRepresentation","replace","host","domain","protocols_re","test","path","pathmatch","matched","undefined","ex","URIError","filter","length","arg","parse","legacy","URL","authmatch","whatwg","username","password","slashes","port","hostname","search","query","pathname","href"],"sources":["D:/WebSpace/SuDaMovie/suda/node_modules/hosted-git-info/index.js"],"sourcesContent":["'use strict'\nvar url = require('url')\nvar gitHosts = require('./git-host-info.js')\nvar GitHost = module.exports = require('./git-host.js')\n\nvar protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n}\n\nfunction protocolToRepresentation (protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1)\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n}\n\nvar cache = {}\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') return\n  var key = giturl + JSON.stringify(opts || {})\n\n  if (!(key in cache)) {\n    cache[key] = fromUrl(giturl, opts)\n  }\n\n  return cache[key]\n}\n\nfunction fromUrl (giturl, opts) {\n  if (giturl == null || giturl === '') return\n  var url = fixupUnqualifiedGist(\n    isGitHubShorthand(giturl) ? 'github:' + giturl : giturl\n  )\n  var parsed = parseGitUrl(url)\n  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\\/)?([^#]+)/)\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName]\n      var auth = null\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = parsed.auth\n      }\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null\n      var user = null\n      var project = null\n      var defaultRepresentation = null\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])\n        project = decodeURIComponent(shortcutMatch[3].replace(/\\.git$/, ''))\n        defaultRepresentation = 'shortcut'\n      } else {\n        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return\n        if (!parsed.path) return\n        var pathmatch = gitHostInfo.pathmatch\n        var matched = parsed.path.match(pathmatch)\n        if (!matched) return\n        /* istanbul ignore else */\n        if (matched[1] !== null && matched[1] !== undefined) {\n          user = decodeURIComponent(matched[1].replace(/^:/, ''))\n        }\n        project = decodeURIComponent(matched[2])\n        defaultRepresentation = protocolToRepresentation(parsed.protocol)\n      }\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)\n    } catch (ex) {\n      /* istanbul ignore else */\n      if (ex instanceof URIError) {\n      } else throw ex\n    }\n  }).filter(function (gitHostInfo) { return gitHostInfo })\n  if (matches.length !== 1) return\n  return matches[0]\n}\n\nfunction isGitHubShorthand (arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg)\n}\n\nfunction fixupUnqualifiedGist (giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl)\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host\n  } else {\n    return giturl\n  }\n}\n\nfunction parseGitUrl (giturl) {\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/)\n  if (!matched) {\n    var legacy = url.parse(giturl)\n    // If we don't have url.URL, then sorry, this is just not fixable.\n    // This affects Node <= 6.12.\n    if (legacy.auth && typeof url.URL === 'function') {\n      // git urls can be in the form of scp-style/ssh-connect strings, like\n      // git+ssh://user@host.com:some/path, which the legacy url parser\n      // supports, but WhatWG url.URL class does not.  However, the legacy\n      // parser de-urlencodes the username and password, so something like\n      // https://user%3An%40me:p%40ss%3Aword@x.com/ becomes\n      // https://user:n@me:p@ss:word@x.com/ which is all kinds of wrong.\n      // Pull off just the auth and host, so we dont' get the confusing\n      // scp-style URL, then pass that to the WhatWG parser to get the\n      // auth properly escaped.\n      var authmatch = giturl.match(/[^@]+@[^:/]+/)\n      /* istanbul ignore else - this should be impossible */\n      if (authmatch) {\n        var whatwg = new url.URL(authmatch[0])\n        legacy.auth = whatwg.username || ''\n        if (whatwg.password) legacy.auth += ':' + whatwg.password\n      }\n    }\n    return legacy\n  }\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] +\n          '/' + matched[3] + (matched[4] || '')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}