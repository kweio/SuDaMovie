{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst net = require('net'),\n  tls = require('tls'),\n  EventParser = require('../entities/EventParser.js'),\n  Message = require('js-message'),\n  fs = require('fs'),\n  Queue = require('@node-ipc/js-queue'),\n  Events = require('event-pubsub');\nlet eventParser = new EventParser();\nclass Client extends Events {\n  constructor(config, log) {\n    super();\n    Object.assign(this, {\n      Client: Client,\n      config: config,\n      queue: new Queue(),\n      socket: false,\n      connect: connect,\n      emit: emit,\n      log: log,\n      retriesRemaining: config.maxRetries || 0,\n      explicitlyDisconnected: false\n    });\n    eventParser = new EventParser(this.config);\n  }\n}\nfunction emit(type, data) {\n  this.log('dispatching event to ', this.id, this.path, ' : ', type, ',', data);\n  let message = new Message();\n  message.type = type;\n  message.data = data;\n  if (this.config.rawBuffer) {\n    message = Buffer.from(type, this.config.encoding);\n  } else {\n    message = eventParser.format(message);\n  }\n  if (!this.config.sync) {\n    this.socket.write(message);\n    return;\n  }\n  this.queue.add(syncEmit.bind(this, message));\n}\nfunction syncEmit(message) {\n  this.log('dispatching event to ', this.id, this.path, ' : ', message);\n  this.socket.write(message);\n}\nfunction connect() {\n  //init client object for scope persistance especially inside of socket events.\n  let client = this;\n  client.log('requested connection to ', client.id, client.path);\n  if (!this.path) {\n    client.log('\\n\\n######\\nerror: ', client.id, ' client has not specified socket path it wishes to connect to.');\n    return;\n  }\n  const options = {};\n  if (!client.port) {\n    client.log('Connecting client on Unix Socket :', client.path);\n    options.path = client.path;\n    if (process.platform === 'win32' && !client.path.startsWith('\\\\\\\\.\\\\pipe\\\\')) {\n      options.path = options.path.replace(/^\\//, '');\n      options.path = options.path.replace(/\\//g, '-');\n      options.path = `\\\\\\\\.\\\\pipe\\\\${options.path}`;\n    }\n    client.socket = net.connect(options);\n  } else {\n    options.host = client.path;\n    options.port = client.port;\n    if (client.config.interface.localAddress) {\n      options.localAddress = client.config.interface.localAddress;\n    }\n    if (client.config.interface.localPort) {\n      options.localPort = client.config.interface.localPort;\n    }\n    if (client.config.interface.family) {\n      options.family = client.config.interface.family;\n    }\n    if (client.config.interface.hints) {\n      options.hints = client.config.interface.hints;\n    }\n    if (client.config.interface.lookup) {\n      options.lookup = client.config.interface.lookup;\n    }\n    if (!client.config.tls) {\n      client.log('Connecting client via TCP to', options);\n      client.socket = net.connect(options);\n    } else {\n      client.log('Connecting client via TLS to', client.path, client.port, client.config.tls);\n      if (client.config.tls.private) {\n        client.config.tls.key = fs.readFileSync(client.config.tls.private);\n      }\n      if (client.config.tls.public) {\n        client.config.tls.cert = fs.readFileSync(client.config.tls.public);\n      }\n      if (client.config.tls.trustedConnections) {\n        if (typeof client.config.tls.trustedConnections === 'string') {\n          client.config.tls.trustedConnections = [client.config.tls.trustedConnections];\n        }\n        client.config.tls.ca = [];\n        for (let i = 0; i < client.config.tls.trustedConnections.length; i++) {\n          client.config.tls.ca.push(fs.readFileSync(client.config.tls.trustedConnections[i]));\n        }\n      }\n      Object.assign(client.config.tls, options);\n      client.socket = tls.connect(client.config.tls);\n    }\n  }\n  client.socket.setEncoding(this.config.encoding);\n  client.socket.on('error', function (err) {\n    client.log('\\n\\n######\\nerror: ', err);\n    client.publish('error', err);\n  });\n  client.socket.on('connect', function connectionMade() {\n    client.publish('connect');\n    client.retriesRemaining = client.config.maxRetries;\n    client.log('retrying reset');\n  });\n  client.socket.on('close', function connectionClosed() {\n    client.log('connection closed', client.id, client.path, client.retriesRemaining, 'tries remaining of', client.config.maxRetries);\n    if (client.config.stopRetrying || client.retriesRemaining < 1 || client.explicitlyDisconnected) {\n      client.publish('disconnect');\n      client.log(client.config.id, 'exceeded connection rety amount of', ' or stopRetrying flag set.');\n      client.socket.destroy();\n      client.publish('destroy');\n      client = undefined;\n      return;\n    }\n    setTimeout(function retryTimeout() {\n      if (client.explicitlyDisconnected) {\n        return;\n      }\n      client.retriesRemaining--;\n      client.connect();\n    }.bind(null, client), client.config.retry);\n    client.publish('disconnect');\n  });\n  client.socket.on('data', function (data) {\n    client.log('## received events ##');\n    if (client.config.rawBuffer) {\n      client.publish('data', Buffer.from(data, client.config.encoding));\n      if (!client.config.sync) {\n        return;\n      }\n      client.queue.next();\n      return;\n    }\n    if (!this.ipcBuffer) {\n      this.ipcBuffer = '';\n    }\n    data = this.ipcBuffer += data;\n    if (data.slice(-1) != eventParser.delimiter || data.indexOf(eventParser.delimiter) == -1) {\n      client.log('Messages are large, You may want to consider smaller messages.');\n      return;\n    }\n    this.ipcBuffer = '';\n    const events = eventParser.parse(data);\n    const eCount = events.length;\n    for (let i = 0; i < eCount; i++) {\n      let message = new Message();\n      message.load(events[i]);\n      client.log('detected event', message.type, message.data);\n      client.publish(message.type, message.data);\n    }\n    if (!client.config.sync) {\n      return;\n    }\n    client.queue.next();\n  });\n}\nmodule.exports = Client;","map":{"version":3,"names":["net","require","tls","EventParser","Message","fs","Queue","Events","eventParser","Client","constructor","config","log","Object","assign","queue","socket","connect","emit","retriesRemaining","maxRetries","explicitlyDisconnected","type","data","id","path","message","rawBuffer","Buffer","from","encoding","format","sync","write","add","syncEmit","bind","client","options","port","process","platform","startsWith","replace","host","interface","localAddress","localPort","family","hints","lookup","private","key","readFileSync","public","cert","trustedConnections","ca","i","length","push","setEncoding","on","err","publish","connectionMade","connectionClosed","stopRetrying","destroy","undefined","setTimeout","retryTimeout","retry","next","ipcBuffer","slice","delimiter","indexOf","events","parse","eCount","load","module","exports"],"sources":["D:/WebSpace/SuDaMovie/suda/node_modules/@achrinza/node-ipc/dao/client.js"],"sourcesContent":["'use strict';\n\nconst net = require('net'),\n    tls = require('tls'),\n    EventParser = require('../entities/EventParser.js'),\n    Message = require('js-message'),\n    fs = require('fs'),\n    Queue = require('@node-ipc/js-queue'),\n    Events = require('event-pubsub');\n\nlet eventParser = new EventParser();\n\nclass Client extends Events{\n    constructor(config,log){\n        super();\n        Object.assign(\n            this,\n            {\n                Client  : Client,\n                config  : config,\n                queue   : new Queue,\n                socket  : false,\n                connect : connect,\n                emit    : emit,\n                log     : log,\n                retriesRemaining:config.maxRetries||0,\n                explicitlyDisconnected: false\n            }\n        );\n\n        eventParser=new EventParser(this.config);\n    }\n}\n\nfunction emit(type,data){\n    this.log('dispatching event to ', this.id, this.path, ' : ', type, ',', data);\n\n    let message=new Message;\n    message.type=type;\n    message.data=data;\n\n    if(this.config.rawBuffer){\n        message=Buffer.from(type,this.config.encoding);\n    }else{\n        message=eventParser.format(message);\n    }\n\n    if(!this.config.sync){\n        this.socket.write(message);\n        return;\n    }\n\n    this.queue.add(\n        syncEmit.bind(this,message)\n    );\n}\n\nfunction syncEmit(message){\n    this.log('dispatching event to ', this.id, this.path, ' : ', message);\n    this.socket.write(message);\n}\n\nfunction connect(){\n    //init client object for scope persistance especially inside of socket events.\n    let client=this;\n\n    client.log('requested connection to ', client.id, client.path);\n    if(!this.path){\n        client.log('\\n\\n######\\nerror: ', client.id ,' client has not specified socket path it wishes to connect to.');\n        return;\n    }\n\n    const options={};\n\n    if(!client.port){\n        client.log('Connecting client on Unix Socket :', client.path);\n\n        options.path=client.path;\n\n        if (process.platform ==='win32' && !client.path.startsWith('\\\\\\\\.\\\\pipe\\\\')){\n            options.path = options.path.replace(/^\\//, '');\n            options.path = options.path.replace(/\\//g, '-');\n            options.path= `\\\\\\\\.\\\\pipe\\\\${options.path}`;\n        }\n\n        client.socket = net.connect(options);\n    }else{\n        options.host=client.path;\n        options.port=client.port;\n\n        if(client.config.interface.localAddress){\n          options.localAddress=client.config.interface.localAddress;\n        }\n\n        if(client.config.interface.localPort){\n          options.localPort=client.config.interface.localPort;\n        }\n\n        if(client.config.interface.family){\n          options.family=client.config.interface.family;\n        }\n\n        if(client.config.interface.hints){\n          options.hints=client.config.interface.hints;\n        }\n\n        if(client.config.interface.lookup){\n          options.lookup=client.config.interface.lookup;\n        }\n\n        if(!client.config.tls){\n            client.log('Connecting client via TCP to', options);\n            client.socket = net.connect(options);\n        }else{\n            client.log('Connecting client via TLS to', client.path ,client.port,client.config.tls);\n            if(client.config.tls.private){\n                client.config.tls.key=fs.readFileSync(client.config.tls.private);\n            }\n            if(client.config.tls.public){\n                client.config.tls.cert=fs.readFileSync(client.config.tls.public);\n            }\n            if(client.config.tls.trustedConnections){\n                if(typeof client.config.tls.trustedConnections === 'string'){\n                    client.config.tls.trustedConnections=[client.config.tls.trustedConnections];\n                }\n                client.config.tls.ca=[];\n                for(let i=0; i<client.config.tls.trustedConnections.length; i++){\n                    client.config.tls.ca.push(\n                        fs.readFileSync(client.config.tls.trustedConnections[i])\n                    );\n                }\n            }\n\n            Object.assign(client.config.tls,options);\n\n            client.socket = tls.connect(\n                client.config.tls\n            );\n        }\n    }\n\n    client.socket.setEncoding(this.config.encoding);\n\n    client.socket.on(\n        'error',\n        function(err){\n            client.log('\\n\\n######\\nerror: ', err);\n            client.publish('error', err);\n\n        }\n    );\n\n    client.socket.on(\n        'connect',\n        function connectionMade(){\n            client.publish('connect');\n            client.retriesRemaining=client.config.maxRetries;\n            client.log('retrying reset');\n        }\n    );\n\n    client.socket.on(\n        'close',\n        function connectionClosed(){\n            client.log('connection closed' ,client.id , client.path,\n            client.retriesRemaining, 'tries remaining of', client.config.maxRetries\n        );\n\n            if(\n                client.config.stopRetrying ||\n                client.retriesRemaining<1 ||\n                client.explicitlyDisconnected\n\n            ){\n                client.publish('disconnect');\n                client.log(\n                    (client.config.id),\n                    'exceeded connection rety amount of',\n                    ' or stopRetrying flag set.'\n                );\n\n                client.socket.destroy();\n                client.publish('destroy');\n                client=undefined;\n\n                return;\n            }\n\n            setTimeout(\n                function retryTimeout(){\n                    if (client.explicitlyDisconnected) {\n                        return;\n                    }\n                    client.retriesRemaining--;\n                    client.connect();\n                }.bind(null,client),\n                client.config.retry\n            );\n\n            client.publish('disconnect');\n        }\n    );\n\n    client.socket.on(\n        'data',\n        function(data) {\n            client.log('## received events ##');\n            if(client.config.rawBuffer){\n                client.publish(\n                   'data',\n                   Buffer.from(data,client.config.encoding)\n                );\n                if(!client.config.sync){\n                    return;\n                }\n\n                client.queue.next();\n                return;\n            }\n\n            if(!this.ipcBuffer){\n                this.ipcBuffer='';\n            }\n\n            data=(this.ipcBuffer+=data);\n\n            if(data.slice(-1)!=eventParser.delimiter || data.indexOf(eventParser.delimiter) == -1){\n                client.log('Messages are large, You may want to consider smaller messages.');\n                return;\n            }\n\n            this.ipcBuffer='';\n\n            const events = eventParser.parse(data);\n            const eCount = events.length;\n            for(let i=0; i<eCount; i++){\n                let message=new Message;\n                message.load(events[i]);\n\n                client.log('detected event', message.type, message.data);\n                client.publish(\n                   message.type,\n                   message.data\n                );\n            }\n\n            if(!client.config.sync){\n                return;\n            }\n\n            client.queue.next();\n        }\n    );\n}\n\nmodule.exports=Client;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}