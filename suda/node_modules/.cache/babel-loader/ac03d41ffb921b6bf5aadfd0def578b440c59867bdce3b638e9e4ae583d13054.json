{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.unshift.js\");\nconst path = require('path');\nconst niceTry = require('nice-try');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\nconst semver = require('semver');\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\n// `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0\nconst supportsShellOption = niceTry(() => semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true)) || false;\nfunction detectShebang(parsed) {\n  parsed.file = resolveCommand(parsed);\n  const shebang = parsed.file && readShebang(parsed.file);\n  if (shebang) {\n    parsed.args.unshift(parsed.file);\n    parsed.command = shebang;\n    return resolveCommand(parsed);\n  }\n  return parsed.file;\n}\nfunction parseNonShell(parsed) {\n  if (!isWin) {\n    return parsed;\n  }\n\n  // Detect & add support for shebangs\n  const commandFile = detectShebang(parsed);\n\n  // We don't need a shell if the command filename is an executable\n  const needsShell = !isExecutableRegExp.test(commandFile);\n\n  // If a shell is required, use cmd.exe and take care of escaping everything correctly\n  // Note that `forceShell` is an hidden option used only in tests\n  if (parsed.options.forceShell || needsShell) {\n    // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n    // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n    // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n    // we need to double escape them\n    const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n    // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n    // This is necessary otherwise it will always fail with ENOENT in those cases\n    parsed.command = path.normalize(parsed.command);\n\n    // Escape command & arguments\n    parsed.command = escape.command(parsed.command);\n    parsed.args = parsed.args.map(arg => escape.argument(arg, needsDoubleEscapeMetaChars));\n    const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n    parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n    parsed.command = process.env.comspec || 'cmd.exe';\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  }\n\n  return parsed;\n}\nfunction parseShell(parsed) {\n  // If node supports the shell option, there's no need to mimic its behavior\n  if (supportsShellOption) {\n    return parsed;\n  }\n\n  // Mimic node shell option\n  // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n  const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n  if (isWin) {\n    parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n    parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  } else {\n    if (typeof parsed.options.shell === 'string') {\n      parsed.command = parsed.options.shell;\n    } else if (process.platform === 'android') {\n      parsed.command = '/system/bin/sh';\n    } else {\n      parsed.command = '/bin/sh';\n    }\n    parsed.args = ['-c', shellCommand];\n  }\n  return parsed;\n}\nfunction parse(command, args, options) {\n  // Normalize arguments, similar to nodejs\n  if (args && !Array.isArray(args)) {\n    options = args;\n    args = null;\n  }\n  args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n  options = Object.assign({}, options); // Clone object to avoid changing the original\n\n  // Build our parsed object\n  const parsed = {\n    command,\n    args,\n    options,\n    file: undefined,\n    original: {\n      command,\n      args\n    }\n  };\n\n  // Delegate further parsing to shell or non-shell\n  return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\nmodule.exports = parse;","map":{"version":3,"names":["path","require","niceTry","resolveCommand","escape","readShebang","semver","isWin","process","platform","isExecutableRegExp","isCmdShimRegExp","supportsShellOption","satisfies","version","detectShebang","parsed","file","shebang","args","unshift","command","parseNonShell","commandFile","needsShell","test","options","forceShell","needsDoubleEscapeMetaChars","normalize","map","arg","argument","shellCommand","concat","join","env","comspec","windowsVerbatimArguments","parseShell","shell","parse","Array","isArray","slice","Object","assign","undefined","original","module","exports"],"sources":["D:/WebSpace/SuDaMovie/suda/node_modules/cross-spawn/lib/parse.js"],"sourcesContent":["'use strict';\n\nconst path = require('path');\nconst niceTry = require('nice-try');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\nconst semver = require('semver');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\n// `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0\nconst supportsShellOption = niceTry(() => semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true)) || false;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parseShell(parsed) {\n    // If node supports the shell option, there's no need to mimic its behavior\n    if (supportsShellOption) {\n        return parsed;\n    }\n\n    // Mimic node shell option\n    // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n    const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n    if (isWin) {\n        parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    } else {\n        if (typeof parsed.options.shell === 'string') {\n            parsed.command = parsed.options.shell;\n        } else if (process.platform === 'android') {\n            parsed.command = '/system/bin/sh';\n        } else {\n            parsed.command = '/bin/sh';\n        }\n\n        parsed.args = ['-c', shellCommand];\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}