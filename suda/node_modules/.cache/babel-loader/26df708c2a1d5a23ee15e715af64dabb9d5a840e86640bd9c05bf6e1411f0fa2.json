{"ast":null,"code":"'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + ['\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '\\\\<\\\\<\\\\<', '>>', '>\\\\&', '<\\\\&', '[&;()|<>]'].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n  TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);\n}\nfunction parseInternal(s, env, opts) {\n  var chunker = new RegExp(['(' + CONTROL + ')',\n  // control chars\n  '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'].join('|'), 'g');\n  var match = s.match(chunker).filter(Boolean);\n  if (!match) {\n    return [];\n  }\n  if (!env) {\n    env = {};\n  }\n  if (!opts) {\n    opts = {};\n  }\n  var commented = false;\n  function getVar(_, pre, key) {\n    var r = typeof env === 'function' ? env(key) : env[key];\n    if (r === undefined && key != '') {\n      r = '';\n    } else if (r === undefined) {\n      r = '$';\n    }\n    if (typeof r === 'object') {\n      return pre + TOKEN + JSON.stringify(r) + TOKEN;\n    }\n    return pre + r;\n  }\n  return match.map(function (s, j) {\n    if (commented) {\n      return void undefined;\n    }\n    if (RegExp('^' + CONTROL + '$').test(s)) {\n      return {\n        op: s\n      };\n    }\n\n    // Hand-written scanner/parser for Bash quoting rules:\n    //\n    // 1. inside single quotes, all characters are printed literally.\n    // 2. inside double quotes, all characters are printed literally\n    //    except variables prefixed by '$' and backslashes followed by\n    //    either a double quote or another backslash.\n    // 3. outside of any quotes, backslashes are treated as escape\n    //    characters and not printed (unless they are themselves escaped)\n    // 4. quote context can switch mid-token if there is no whitespace\n    //     between the two quote contexts (e.g. all'one'\"token\" parses as\n    //     \"allonetoken\")\n    var SQ = \"'\";\n    var DQ = '\"';\n    var DS = '$';\n    var BS = opts.escape || '\\\\';\n    var quote = false;\n    var esc = false;\n    var out = '';\n    var isGlob = false;\n    var i;\n    function parseEnvVar() {\n      i += 1;\n      var varend;\n      var varname;\n      // debugger\n      if (s.charAt(i) === '{') {\n        i += 1;\n        if (s.charAt(i) === '}') {\n          throw new Error('Bad substitution: ' + s.substr(i - 2, 3));\n        }\n        varend = s.indexOf('}', i);\n        if (varend < 0) {\n          throw new Error('Bad substitution: ' + s.substr(i));\n        }\n        varname = s.substr(i, varend - i);\n        i = varend;\n      } else if (/[*@#?$!_-]/.test(s.charAt(i))) {\n        varname = s.charAt(i);\n        i += 1;\n      } else {\n        varend = s.substr(i).match(/[^\\w\\d_]/);\n        if (!varend) {\n          varname = s.substr(i);\n          i = s.length;\n        } else {\n          varname = s.substr(i, varend.index);\n          i += varend.index - 1;\n        }\n      }\n      return getVar(null, '', varname);\n    }\n    for (i = 0; i < s.length; i++) {\n      var c = s.charAt(i);\n      isGlob = isGlob || !quote && (c === '*' || c === '?');\n      if (esc) {\n        out += c;\n        esc = false;\n      } else if (quote) {\n        if (c === quote) {\n          quote = false;\n        } else if (quote == SQ) {\n          out += c;\n        } else {\n          // Double quote\n          if (c === BS) {\n            i += 1;\n            c = s.charAt(i);\n            if (c === DQ || c === BS || c === DS) {\n              out += c;\n            } else {\n              out += BS + c;\n            }\n          } else if (c === DS) {\n            out += parseEnvVar();\n          } else {\n            out += c;\n          }\n        }\n      } else if (c === DQ || c === SQ) {\n        quote = c;\n      } else if (RegExp('^' + CONTROL + '$').test(c)) {\n        return {\n          op: s\n        };\n      } else if (/^#$/.test(c)) {\n        commented = true;\n        if (out.length) {\n          return [out, {\n            comment: s.slice(i + 1) + match.slice(j + 1).join(' ')\n          }];\n        }\n        return [{\n          comment: s.slice(i + 1) + match.slice(j + 1).join(' ')\n        }];\n      } else if (c === BS) {\n        esc = true;\n      } else if (c === DS) {\n        out += parseEnvVar();\n      } else {\n        out += c;\n      }\n    }\n    if (isGlob) {\n      return {\n        op: 'glob',\n        pattern: out\n      };\n    }\n    return out;\n  }).reduce(function (prev, arg) {\n    // finalize parsed aruments\n    if (arg === undefined) {\n      return prev;\n    }\n    return prev.concat(arg);\n  }, []);\n}\nmodule.exports = function parse(s, env, opts) {\n  var mapped = parseInternal(s, env, opts);\n  if (typeof env !== 'function') {\n    return mapped;\n  }\n  return mapped.reduce(function (acc, s) {\n    if (typeof s === 'object') {\n      return acc.concat(s);\n    }\n    var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n    if (xs.length === 1) {\n      return acc.concat(xs[0]);\n    }\n    return acc.concat(xs.filter(Boolean).map(function (x) {\n      if (RegExp('^' + TOKEN).test(x)) {\n        return JSON.parse(x.split(TOKEN)[1]);\n      }\n      return x;\n    }));\n  }, []);\n};","map":{"version":3,"names":["CONTROL","join","META","BAREWORD","SINGLE_QUOTE","DOUBLE_QUOTE","TOKEN","i","Math","pow","random","toString","parseInternal","s","env","opts","chunker","RegExp","match","filter","Boolean","commented","getVar","_","pre","key","r","undefined","JSON","stringify","map","j","test","op","SQ","DQ","DS","BS","escape","quote","esc","out","isGlob","parseEnvVar","varend","varname","charAt","Error","substr","indexOf","length","index","c","comment","slice","pattern","reduce","prev","arg","concat","module","exports","parse","mapped","acc","xs","split","x"],"sources":["D:/WebSpace/SuDaMovie/suda/node_modules/shell-quote/parse.js"],"sourcesContent":["'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '\\\\<\\\\<\\\\<', '>>', '>\\\\&', '<\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (Math.pow(16, 8) * Math.random()).toString(16);\n}\n\nfunction parseInternal(s, env, opts) {\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n\t].join('|'), 'g');\n\tvar match = s.match(chunker).filter(Boolean);\n\n\tif (!match) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\tif (!opts) {\n\t\topts = {};\n\t}\n\n\tvar commented = false;\n\n\tfunction getVar(_, pre, key) {\n\t\tvar r = typeof env === 'function' ? env(key) : env[key];\n\t\tif (r === undefined && key != '') {\n\t\t\tr = '';\n\t\t} else if (r === undefined) {\n\t\t\tr = '$';\n\t\t}\n\n\t\tif (typeof r === 'object') {\n\t\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t\t}\n\t\treturn pre + r;\n\t}\n\n\treturn match.map(function (s, j) {\n\t\tif (commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (RegExp('^' + CONTROL + '$').test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar SQ = \"'\";\n\t\tvar DQ = '\"';\n\t\tvar DS = '$';\n\t\tvar BS = opts.escape || '\\\\';\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\t// debugger\n\t\t\tif (s.charAt(i) === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i - 2, 3));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.substr(i, varend - i);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(s.charAt(i))) {\n\t\t\t\tvarname = s.charAt(i);\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvarend = s.substr(i).match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = s.substr(i);\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = s.substr(i, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(null, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (RegExp('^' + CONTROL + '$').test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if ((/^#$/).test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, { comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t\t}\n\t\t\t\treturn [{ comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed aruments\n\t\tif (arg === undefined) {\n\t\t\treturn prev;\n\t\t}\n\t\treturn prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (RegExp('^' + TOKEN).test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}